# -*- coding: utf-8 -*-


'''
http://golovolomka.hobby.ru/math/otvet/hard20.htm
'''

N_MAX = 800 #ограничение перебора
#N_MAX = 99


'''
p(x) - множество произведений пар допустимых чисел, 
сумма которых равна x. Например, p(8) = { 12, 15 }, p(10) = { 16, 21, 24, 25 }.
'''

def p(x):
    res = []
    for i in range(2,x):
        for j in range(i,x):
            if i + j == x and i != j: res.append(i * j)
    return res

#print(p(10))

'''
s(x) - множество сумм пар допустимых чисел, произведение которых равно x. 
Например, s(11) - пустое множество, s(15) = { 8 }, s(24) = { 14, 11, 10 }.
'''
        
def s(x):
    res = []
    for i in range(2,x):
        for j in range(i,x):
            if i * j == x and i != j: res.append(i + j)
    return res

#print(s(15))
    
'''
P: "Я не могу определить эти числа" 

Утверждение (1) в переводе на наши обозначения означает следующее:

s(X) содержит более одного элемента.     (1')

Обозначим через P1 множество чисел, удовлетворяющих (1').

P1 = { 12 16 18 20 24 28 30 32 36 40 42 45 48 ... }
'''

P1 = []
for i in range(2,N_MAX):
    if len(s(i)) > 1: P1.append(i)
    
#print(P1)


    
'''
(2) S: "Я знаю, что Вы не можете этого сделать"

означает, что

p(Y) является подмножеством P1.

Все подходящие под это утверждение Y занесем в S1.

Замечание: В частности, отсюда следует, что S1 не содержит чисел, 
представимых в виде суммы двух простых.

Известная гипотеза Гольдбаха-Эйлера (не доказанная, но проверенная 
для всех досягаемых на ЭВМ чисел) утверждает, что каждое четное число, начиная с 4, 
является суммой двух простых. Следовательно, S1 не содержит четных чисел. 
Кроме того, S1 не содержит чисел вида p+2, где p - простое.
'''
    
S1 = []
for i in range(2,N_MAX):
    if set(p(i)).issubset(set(P1)): S1.append(i)

    
'''
(3) P: "Но тогда я знаю эти числа"

В P2 попадают только такие Х, для которых
пересечение множества s(X) и множества S1 состоит ровно из одного элемента

это означает, что если есть только один элемент в массиве s(X)
который встречается в S1, тогда Х попадает в Р2.
'''

P2 = []
for i in range(2,N_MAX):
    Si = s(i)
    temp = []
    for j in range(len(Si)):
        if Si[j] in S1: temp.append(Si[j])
    if len(temp) == 1: P2.append(i)
    
#print(P2)
    
    
'''
(4) S: "Тогда и я знаю эти числа"

означает, что

пересечение p(Y) и множества P2 состоит ровно из одного элемента X

(иначе господин S не смог бы выбрать между двумя или более вариантами).

Пусть S2 - множество тех Y из S1, для которых выполнено условие (4').
В отыскании множества S2 и состоит, собственно, задача (для каждого Y из S2 
мы однозначно определяем X из условия (4'), а зная X и Y, легко находим загаданные числа).

'''

S2 = []
X = -1 # X - n * m
for i in range(len(S1)):
    Py = p(S1[i])
    temp = []
    for j in range(len(Py)):
        if Py[j] in P2: temp.append(Py[j])
    if len(temp) == 1: S2.append(S1[i]); X = temp[0]

print(S2)
print(X)















