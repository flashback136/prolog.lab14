% equation - поиск корней квадратного уравнения

delta(A, B, C, D):- D is B*B - 4*A*C.
equation(A,B,C,X) :-
 delta(A,B,C,D1),
 (  D1 < 0
 -> X is 0
 ;  D1 =:= 0
 -> X is -B/2*A
 ;  X1 is (-B+sqrt(D1))/2*A
 ,	X2 is (-B-sqrt(D1))/2*A
 ,  X = [X1,X2]
 ).



/*
найти множество L, элементом которого является T,
такое, что
среди чисел от 2 до Х
есть числа А и В, входящие в этот диапазон
такие что А не равно В,
сумма А и В равна Х
произведедение А и В и есть Т.
A^B^Goal нужно чтобы все результаты сложились в один лист
*/
p(X, L):-
    setof(T, 
          A^B^(numlist(2,X,NL),
          member(A,NL),member(B,NL), 
          A=\=B, X is A + B, T is A*B), 
          L), !; L = [].

/*
найти множество L, элементом которого является T,
такое, что
среди чисел от 2 до Х
есть числа А и В, входящие в этот диапазон
такие что А не равно В,
произведение А и В равна Х
сумма А и В и есть Т.
При этом, если L - пустое множество, вернуть пустой список.

Сделано так:
сразу после setof идет оператор "," (И) и дальше оператор "!" (Cut),
Оператор ! работает так:
если стоящее слева от него выражение истинно, дальше проверка не идет
если бы его там не было, а просто стояла точка с запятой, тогда всегда было бы два решения:
множество L и пустой список, либо если L - пустое множество, тогда только пустой список
с помощью ! мы всегда будем получать только одно решение: либо множество L, либо [].
*/
s(X, L):-
    setof(T, 
          A^B^(numlist(2,X,NL),
          member(A,NL),member(B,NL), 
          A=\=B, X is A * B, T is A+B),
          L), !; 
          L= [].

/*

(1) P: "Я не могу определить эти числа" 

Утверждение (1) в переводе на наши обозначения означает следующее:

s(X) содержит более одного элемента.     (1')

Обозначим через P1 множество чисел, удовлетворяющих (1').

P1 вычисляется так:
P1 есть множество элементов L, таких, что
множество s(L) состоит более чем из одного элемента 
 */

getP1(L):-
    findall(Y,
           (numlist(2, 800, NL),
              member(Y, NL),
              s(Y, L),
              length(L, Len),
              Len > 1),
           L).

/*
(2) S: "Я знаю, что Вы не можете этого сделать"

означает, что

p(Y) является подмножеством P1.

Все подходящие под это утверждение Y занесем в S1.
*/

getS1(L):-
    getP1(P1),
    findall(Y,
            (numlist(2,800,NL),
                member(Y, NL),
                p(Y, L1),
                subset(L1,P1)),
            L).



/*
(3) P: "Но тогда я знаю эти числа"

В P2 попадают только такие Х, для которых
пересечение множества s(X) и множества S1 состоит ровно из одного элемента

это означает, что если есть только один элемент в множестве s(X)
который встречается в S1, тогда Х попадает в Р2.
*/ 

getP2(L):-
    getS1(S1),
    findall(Y,
           (numlist(2, 800, NL),
              member(Y, NL),
              s(Y, Si),
              intersection(Si, S1, Intersec),
              length(Intersec, Len),
              Len = 1),
            L).
/*
(4) S: "Тогда и я знаю эти числа"

означает, что

пересечение p(Y) и множества P2 состоит ровно из одного элемента X

(иначе господин S не смог бы выбрать между двумя или более вариантами).

Пусть S2 - множество тех Y из S1, для которых выполнено условие (4').
В отыскании множества S2 и состоит, собственно, задача (для каждого Y из S2 
мы однозначно определяем X из условия (4'), а зная X и Y, 
находим загаданные числа, решая квадратное уравнение).
*/

getS2(L):-
    getS1(S1),
    getP2(P2),
    findall(K,   
           (member(Y, S1),
              p(Y, Pi),
              intersection(Pi, P2, Intersec),
              length(Intersec, Len),
              Len = 1,
              T is Intersec,
              K = [Y, T]),
            [L|_]).

solve(A):-
    getS2([H|T]),
    equation(1,-H, T, A).

    


    
